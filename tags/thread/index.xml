<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Thread on Shawn's blog</title><link>https://blog.programmer.work/tags/thread/</link><description>Recent content in Thread on Shawn's blog</description><generator>Hugo</generator><language>zh-CN</language><managingEditor>shawnbluce@gmail.com (Shawn)</managingEditor><webMaster>shawnbluce@gmail.com (Shawn)</webMaster><lastBuildDate>Fri, 17 Jan 2025 01:49:53 +0000</lastBuildDate><atom:link href="https://blog.programmer.work/tags/thread/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 使用 threading 实现多线程</title><link>https://blog.programmer.work/posts/python-threading/</link><pubDate>Mon, 12 Dec 2016 07:39:00 +0000</pubDate><author>shawnbluce@gmail.com (Shawn)</author><guid>https://blog.programmer.work/posts/python-threading/</guid><description>&lt;h1 id="0x00-多线程"&gt;0X00 多线程&lt;/h1&gt;
&lt;p&gt;多线程是个提高程序运行效率的好办法，本来要顺序执行的程序现在可以并行执行，可想而知效率要提高很多。但是多线程也不是能提高所有程序的效率。程序的两个极端是‘CPU密集型’和‘I/O密集型’两种，多线程技术比较适用于后者，因为在串行结构中当你去读写磁盘或者网络通信的时候CPU是闲着的，毕竟网络比磁盘要慢几个数量级，磁盘比内存慢几个数量级，内存又比CPU慢几个数量级。多线程技术就可以同时执行，比如你的程序需要发送N个http数据包（10秒），还需要将文件从一个位置复制到另一个位置（20秒），然后还需要统计另一个文件中&amp;rsquo;hello,world&amp;rsquo;字符串的出现次数（4秒），现在一共是要用34秒。但是因为这些操作之间没有关联，所以可以写成多线程程序，几乎只需要20秒就完成了。这是针对I/O密集型的，如果是CPU密集型的就不行了。比如我的程序要计算1000的阶乘（10秒），还要计算100000的累加（5秒），那么即使程序是并行的，还是会要用15秒，甚至更多。因为当程序使用CPU的时候CPU是通过轮转来执行的，IO密集型的程序可以在IO的同时用CPU计算，但是这里的CPU密集型就只能先执行一会儿线程1再执行一会儿线程2。所以就需要15秒，甚至会更多，因为CPU在切换的时候需要耗时。解决CPU密集型程序的多线程问题就是CPU的事情了，比如Intel的超线程技术，可以在同一个核心上真正的并行两个线程，所以称之为‘双核四线程’或者‘四核八线程’，我们这里具体的先不谈，谈我也不知道。&lt;/p&gt;</description></item></channel></rss>