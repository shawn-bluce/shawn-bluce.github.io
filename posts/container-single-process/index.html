<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>容器的单进程模型 - Shawn's blog</title><meta name=Description content="分享我的知识、经验、生活与感悟"><meta property="og:url" content="https://blog.programmer.work/posts/container-single-process/"><meta property="og:site_name" content="Shawn's blog"><meta property="og:title" content="容器的单进程模型"><meta property="og:description" content="0X00 Linux 的进程关系 既然想搞清楚容器的单进程模型，那自然需要先复习一下 Linux 下的基本进程关系了。你说你用的是 Windows Container？不懂，不会，打扰了😢
我们知道 Linux 下会有一个 PID=1 的进程来带动其他进程，以前 PID=1 的进程是 init 后来大家都在用 systemd ，这里就不多说了，只来回顾一下「孤儿进程」和「僵尸进程」这两个概念。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-16T13:26:00+00:00"><meta property="article:modified_time" content="2025-01-16T07:36:48+00:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Docker"><meta property="og:image" content="https://blog.programmer.work/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.programmer.work/logo.png"><meta name=twitter:title content="容器的单进程模型"><meta name=twitter:description content="0X00 Linux 的进程关系 既然想搞清楚容器的单进程模型，那自然需要先复习一下 Linux 下的基本进程关系了。你说你用的是 Windows Container？不懂，不会，打扰了😢
我们知道 Linux 下会有一个 PID=1 的进程来带动其他进程，以前 PID=1 的进程是 init 后来大家都在用 systemd ，这里就不多说了，只来回顾一下「孤儿进程」和「僵尸进程」这两个概念。"><meta name=application-name content="Shawn's blog"><meta name=apple-mobile-web-app-title content="Shawn's blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.programmer.work/posts/container-single-process/><link rel=prev href=https://blog.programmer.work/posts/k8s-deploy-tips/><link rel=next href=https://blog.programmer.work/posts/virtualization-container-docker/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"容器的单进程模型","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.programmer.work\/posts\/container-single-process\/"},"genre":"posts","keywords":"Linux, Docker","wordcount":1639,"url":"https:\/\/blog.programmer.work\/posts\/container-single-process\/","datePublished":"2022-12-16T13:26:00+00:00","dateModified":"2025-01-16T07:36:48+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Shawn"},"description":""}</script></head><body data-header-desktop=auto data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"dark"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"dark"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Shawn's blog">Shawn's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shawn's blog">Shawn's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">容器的单进程模型</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://blog.programmer.work title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Shawn</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-12-16>2022-12-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 1639 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents></nav></div></div><div class=content id=content><h1 id=0x00-linux-的进程关系>0X00 Linux 的进程关系</h1><p>既然想搞清楚容器的单进程模型，那自然需要先复习一下 Linux 下的基本进程关系了。你说你用的是 Windows Container？不懂，不会，打扰了😢</p><p>我们知道 Linux 下会有一个 PID=1 的进程来带动其他进程，以前 PID=1 的进程是 init 后来大家都在用 systemd ，这里就不多说了，只来回顾一下「孤儿进程」和「僵尸进程」这两个概念。</p><p>这里来模拟一个场景，默认 PID=1 的是 systemd</p><ol><li>打开运行一个新进程</li><li>新进程 fork 了一个子进程出来</li><li>子进程持续运行</li><li>此时父进程终止了</li><li>子进程成为<strong>孤儿进程</strong> （因为他的父进程挂了）</li><li>该子进程会交由 systemd 接管</li><li>当子进程结束之后 systemd 会替它「收尸」，也就是释放、回收资源之类的</li></ol><p>还有另一个场景：某菜鸡程序员（可能是我）写了个程序，现在运行起来了。该进程会 fork 新进程，每隔一会儿就会 fork 一个，但是该进程并没有 wait/waitpid 这种操作（俗称管杀不管埋）。所以当子进程结束后资源并没有被回收，甚至 PID 都还占着。这种已经结束了但是没被回收的进程就叫<strong>僵尸进城</strong> 噢不，叫<strong>僵尸进程</strong> 。</p><p>需要注意的一点就是，孤儿进程并不是什么大问题，systemd 会解决它的；僵尸进程也 <em>不都</em> 有问题，任何进程在结束之后和被回收之前，都处于这个状态，真正要注意的是源源不断产生僵尸进程的那个进程，就算只是一直占着 PID 也不是个事儿嘛。</p><h1 id=0x01-容器的本质>0X01 容器的本质</h1><p>好了现在已经回忆起僵尸进程和孤儿进程这两个概念了，接下来回忆一下容器的本质。简单来说的话容器（以 Docker for Linux 为例）并非虚拟化，而是在宿主机上运行的一个普通进程而已，只是通过 Linux 自身的一些特性将其与宿主机环境隔离开了而已。当然了，既然不是虚拟化也就没有宿主机这种说法，这里只是图个方便才这么说的。如果你想更多的了解容器技术本身，推荐下面这一系列文章</p><ul><li><a href=https://coolshell.cn/articles/17010.html target=_blank rel="noopener noreffer">Docker基础技术：Linux Namespace（上）</a></li><li><a href=https://coolshell.cn/articles/17029.html target=_blank rel="noopener noreffer">Docker基础技术：Linux Namespace（下）</a></li><li><a href=https://coolshell.cn/articles/17049.html target=_blank rel="noopener noreffer">Docker基础技术：Linux CGroup</a></li><li><a href=https://coolshell.cn/articles/17061.html target=_blank rel="noopener noreffer">Docker基础技术：AUFS</a></li><li><a href=https://coolshell.cn/articles/17200.html target=_blank rel="noopener noreffer">Docker基础技术：DeviceMapper</a></li></ul><h1 id=0x02-单进程模型>0X02 单进程模型</h1><p>既然我们了解了上面两项知识，那么自然也就明白为什么容器里 EntryPoint 的进程是 PID=1 了。接下来我们假设你写了个普通的程序，在程序内部会 fork 一些子进程出来。然后将其搬到了容器里，那么你自己的这个程序运行之后，又 fork 了一堆子孙进程出来，现在你想让 PID=1 的进程负责收尸工作，那么 PID=1 的进程是哪个呢？就是你自己写的那个呀🧐</p><p>如果没搞错的话，一般自己写一个多进程的程序是不太会管僵尸进程子进程这些的，一切交给 systemd 就好了。但是现在 PID=1 的是自己写的那个程序，又没有这个收尸能力，所以才会有这么个「单进程模型」啦。</p><p>那怎么解决呢？有问题就有答案，你可以选择修改你的程序，让它监控子进程、僵尸进程，并且对其进行合理的回收♻️；也可以让每个容器只运行一个进程，多进程就干脆多容器。然后把相关联的几个容器间的网络、文件、数据都给打通，这样一来每个进程都是 PID=1，当它结束的时候直接容器就停止了，也就不会有回收资源的问题了。可是看起来虽然少了监控回收的工作，但是多了打通网络、打通文件系统、打通进程间数据共享的问题，还多了一大堆其他的隐藏工作。这时候知道的小伙伴就知道了，该 Kubernetes 上场了～</p><p>如果你不知道 Kubernetes 的话，可以先简单将其理解成一个容器编排工具，它里面有一个重要的概念叫做 pod。pod 中可以运行一个或多个容器，容器之间共享同一个网络命名空间，也就是说同一个 pod 里的容器 A 可以用 127.0.0.1 访问同处于一个 pod 中的其他容器；pod 中的所有容器也共享一个 Volume，也就是说简单的文件共享也是有的；并且它们之间甚至可以使用 Linux 下标准的进程间通信，例如信号量这些。</p><h1 id=0x03-最后>0X03 最后</h1><p>综上所述，我们得出几条结论</p><ol><li>由于将进程隔离起来，导致容器内部并没有 init/systemd 这种负责收尸的老大哥；</li><li>由于 1 的缘故，我们说容器使用的是单进程模型；</li><li>虽然是单进程模型，但是并非真的只能运行一个进程，你想的话可以自己实现一个 systemd 一样的东西在容器里面玩起来（但是并不推荐）；</li><li>程序/业务真的复杂到这种程度的话，建议引入容器编排工具，例如 Kubernetes；</li></ol><p>参考资料：</p><ul><li><a href=https://zhuanlan.zhihu.com/p/83482791 target=_blank rel="noopener noreffer">为什么说容器是单进程模型</a></li><li><a href=https://xie.infoq.cn/article/5ee74750ecd5fe3eb05569b5d target=_blank rel="noopener noreffer">被忽略的一点：Docker 的单进程模型</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2025-01-16</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/linux/>Linux</a>,&nbsp;<a href=/tags/docker/>Docker</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/k8s-deploy-tips/ class=prev rel=prev title="部署 Kubernetes 集群时遇到的一些问题"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>部署 Kubernetes 集群时遇到的一些问题</a>
<a href=/posts/virtualization-container-docker/ class=next rel=next title=虚拟化、容器、Docker>虚拟化、容器、Docker<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Shawn 💗 Amber</div><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.152.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.0"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2015 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://blog.programmer.work target=_blank>Shawn</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/gitalk/gitalk.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/gitalk/gitalk.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{gitalk:{admin:["shawn-bluce"],clientID:"Ov23ligzD7mU8WBsue6H",clientSecret:"a832d1ba967e3a40f5485aa05e2a9e76f2d77901",id:"2022-12-16T13:26:00Z",owner:"shawn-bluce",repo:"shawn-bluce.github.io",title:"容器的单进程模型"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>