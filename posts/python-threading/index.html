<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Python 使用 threading 实现多线程 - Shawn's blog</title><meta name=Description content="分享我的知识、经验、生活与感悟"><meta property="og:url" content="https://blog.programmer.work/posts/python-threading/"><meta property="og:site_name" content="Shawn's blog"><meta property="og:title" content="Python 使用 threading 实现多线程"><meta property="og:description" content="0X00 多线程 多线程是个提高程序运行效率的好办法，本来要顺序执行的程序现在可以并行执行，可想而知效率要提高很多。但是多线程也不是能提高所有程序的效率。程序的两个极端是‘CPU密集型’和‘I/O密集型’两种，多线程技术比较适用于后者，因为在串行结构中当你去读写磁盘或者网络通信的时候CPU是闲着的，毕竟网络比磁盘要慢几个数量级，磁盘比内存慢几个数量级，内存又比CPU慢几个数量级。多线程技术就可以同时执行，比如你的程序需要发送N个http数据包（10秒），还需要将文件从一个位置复制到另一个位置（20秒），然后还需要统计另一个文件中’hello,world’字符串的出现次数（4秒），现在一共是要用34秒。但是因为这些操作之间没有关联，所以可以写成多线程程序，几乎只需要20秒就完成了。这是针对I/O密集型的，如果是CPU密集型的就不行了。比如我的程序要计算1000的阶乘（10秒），还要计算100000的累加（5秒），那么即使程序是并行的，还是会要用15秒，甚至更多。因为当程序使用CPU的时候CPU是通过轮转来执行的，IO密集型的程序可以在IO的同时用CPU计算，但是这里的CPU密集型就只能先执行一会儿线程1再执行一会儿线程2。所以就需要15秒，甚至会更多，因为CPU在切换的时候需要耗时。解决CPU密集型程序的多线程问题就是CPU的事情了，比如Intel的超线程技术，可以在同一个核心上真正的并行两个线程，所以称之为‘双核四线程’或者‘四核八线程’，我们这里具体的先不谈，谈我也不知道。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-12-12T07:39:00+00:00"><meta property="article:modified_time" content="2025-01-17T01:49:53+00:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Thread"><meta property="og:image" content="https://blog.programmer.work/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.programmer.work/logo.png"><meta name=twitter:title content="Python 使用 threading 实现多线程"><meta name=twitter:description content="0X00 多线程 多线程是个提高程序运行效率的好办法，本来要顺序执行的程序现在可以并行执行，可想而知效率要提高很多。但是多线程也不是能提高所有程序的效率。程序的两个极端是‘CPU密集型’和‘I/O密集型’两种，多线程技术比较适用于后者，因为在串行结构中当你去读写磁盘或者网络通信的时候CPU是闲着的，毕竟网络比磁盘要慢几个数量级，磁盘比内存慢几个数量级，内存又比CPU慢几个数量级。多线程技术就可以同时执行，比如你的程序需要发送N个http数据包（10秒），还需要将文件从一个位置复制到另一个位置（20秒），然后还需要统计另一个文件中’hello,world’字符串的出现次数（4秒），现在一共是要用34秒。但是因为这些操作之间没有关联，所以可以写成多线程程序，几乎只需要20秒就完成了。这是针对I/O密集型的，如果是CPU密集型的就不行了。比如我的程序要计算1000的阶乘（10秒），还要计算100000的累加（5秒），那么即使程序是并行的，还是会要用15秒，甚至更多。因为当程序使用CPU的时候CPU是通过轮转来执行的，IO密集型的程序可以在IO的同时用CPU计算，但是这里的CPU密集型就只能先执行一会儿线程1再执行一会儿线程2。所以就需要15秒，甚至会更多，因为CPU在切换的时候需要耗时。解决CPU密集型程序的多线程问题就是CPU的事情了，比如Intel的超线程技术，可以在同一个核心上真正的并行两个线程，所以称之为‘双核四线程’或者‘四核八线程’，我们这里具体的先不谈，谈我也不知道。"><meta name=application-name content="Shawn's blog"><meta name=apple-mobile-web-app-title content="Shawn's blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.programmer.work/posts/python-threading/><link rel=prev href=https://blog.programmer.work/posts/linux-mysql-mariadb-simple/><link rel=next href=https://blog.programmer.work/posts/page-swap-simple/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Python 使用 threading 实现多线程","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.programmer.work\/posts\/python-threading\/"},"genre":"posts","keywords":"Python, Thread","wordcount":2261,"url":"https:\/\/blog.programmer.work\/posts\/python-threading\/","datePublished":"2016-12-12T07:39:00+00:00","dateModified":"2025-01-17T01:49:53+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Shawn"},"description":""}</script></head><body data-header-desktop=auto data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"dark"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"dark"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Shawn's blog">Shawn's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shawn's blog">Shawn's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Python 使用 threading 实现多线程</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://blog.programmer.work title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Shawn</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2016-12-12>2016-12-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 2261 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 5 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents></nav></div></div><div class=content id=content><h1 id=0x00-多线程>0X00 多线程</h1><p>多线程是个提高程序运行效率的好办法，本来要顺序执行的程序现在可以并行执行，可想而知效率要提高很多。但是多线程也不是能提高所有程序的效率。程序的两个极端是‘CPU密集型’和‘I/O密集型’两种，多线程技术比较适用于后者，因为在串行结构中当你去读写磁盘或者网络通信的时候CPU是闲着的，毕竟网络比磁盘要慢几个数量级，磁盘比内存慢几个数量级，内存又比CPU慢几个数量级。多线程技术就可以同时执行，比如你的程序需要发送N个http数据包（10秒），还需要将文件从一个位置复制到另一个位置（20秒），然后还需要统计另一个文件中&rsquo;hello,world&rsquo;字符串的出现次数（4秒），现在一共是要用34秒。但是因为这些操作之间没有关联，所以可以写成多线程程序，几乎只需要20秒就完成了。这是针对I/O密集型的，如果是CPU密集型的就不行了。比如我的程序要计算1000的阶乘（10秒），还要计算100000的累加（5秒），那么即使程序是并行的，还是会要用15秒，甚至更多。因为当程序使用CPU的时候CPU是通过轮转来执行的，IO密集型的程序可以在IO的同时用CPU计算，但是这里的CPU密集型就只能先执行一会儿线程1再执行一会儿线程2。所以就需要15秒，甚至会更多，因为CPU在切换的时候需要耗时。解决CPU密集型程序的多线程问题就是CPU的事情了，比如Intel的超线程技术，可以在同一个核心上真正的并行两个线程，所以称之为‘双核四线程’或者‘四核八线程’，我们这里具体的先不谈，谈我也不知道。</p><h1 id=0x01-python骗人>0X01 Python骗人</h1><p>说了这么多多线程的好处，但是其实Python不支持真正意义上的多线程编程。在Python中有一个叫做GIL的东西，中文是 <em>全局解释器锁</em> ，这东西控制了Python，让Python只能同时运行一个线程。相当于说真正意义上的多线程是由CPU来控制的，Python中的多线程由GIL控制。如果有一个CPU密集型程序，用C语言写的，运行在一个四核处理器上，采用多线程技术的话最多可以获得4倍的效率提升，但是如果用Python写的话并不会有提高，甚至会变慢，因为线程切换的问题。所以Python多线程相对更加适合写I/O密集型程序，再说了真正的对效率要求很高的CPU密集型程序都用C/C++去了。</p><h1 id=0x02-第一个多线程>0X02 第一个多线程</h1><p>Python中多线程的库一般用<code>thread</code>和<code>threading</code>这两个，<code>thread</code>不推荐新手和一般人使用，<code>threading</code>模块就相当够用了。
有一个程序，如下。两个循环，分别休眠3秒和5秒，串行执行的话需要8秒。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># coding=utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep_3</span>():
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep_5</span>():
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>        start_time <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>        print <span style=color:#e6db74>&#39;start sleep 3&#39;</span>
</span></span><span style=display:flex><span>        sleep_3()
</span></span><span style=display:flex><span>        print <span style=color:#e6db74>&#39;start sleep 5&#39;</span>
</span></span><span style=display:flex><span>        sleep_5()
</span></span><span style=display:flex><span>        end_time <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>        print str(end_time <span style=color:#f92672>-</span> start_time) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; s&#39;</span>
</span></span></code></pre></div><p>输出是这样的</p><pre tabindex=0><code>    start sleep 3
    start sleep 5
    8.00100016594 s
</code></pre><p>然后我们对它进行修改，使其变成多线程程序，虽然改动没有几行。首先引入了threading的库，然后实例化一个threading.Thread对象，将一个函数传进构造方法就行了。然后调用Thread的start方法开始一个线程。join()方法可以等待该线程结束，就像我下面用的，如果我不加那两个等待线程结束的代码，那么就会直接执行输出时间的语句，这样一来统计的时间就不对了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># coding=utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> threading    <span style=color:#75715e># 引入threading</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep_3</span>():
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep_5</span>():
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>        start_time <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>        print <span style=color:#e6db74>&#39;start sleep 3&#39;</span>
</span></span><span style=display:flex><span>        thread_1 <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>sleep_3)     <span style=color:#75715e># 实例化一个线程对象，使线程执行这个函数</span>
</span></span><span style=display:flex><span>        thread_1<span style=color:#f92672>.</span>start()        <span style=color:#75715e># 启动这个线程</span>
</span></span><span style=display:flex><span>        print <span style=color:#e6db74>&#39;start sleep 5&#39;</span>
</span></span><span style=display:flex><span>        thread_2 <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>sleep_5)     <span style=color:#75715e># 实例化一个线程对象，使线程执行这个函数</span>
</span></span><span style=display:flex><span>        thread_2<span style=color:#f92672>.</span>start()        <span style=color:#75715e># 启动这个线程</span>
</span></span><span style=display:flex><span>        thread_1<span style=color:#f92672>.</span>join()     <span style=color:#75715e># 等待thread_1结束</span>
</span></span><span style=display:flex><span>        thread_2<span style=color:#f92672>.</span>join()     <span style=color:#75715e># 等待thread_2结束</span>
</span></span><span style=display:flex><span>        end_time <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>        print str(end_time <span style=color:#f92672>-</span> start_time) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; s&#39;</span>
</span></span></code></pre></div><p>执行结果是这样的</p><pre tabindex=0><code>    start sleep 3
    start sleep 5
    5.00099992752 s
</code></pre><h1 id=0x03-daemon-守护线程>0X03 daemon 守护线程</h1><p>在我们理解中守护线程应该是很重要的，类比于Linux中的守护进程。但是在<code>threading.Thread</code>中偏偏不是。</p><blockquote><p>如果把一个线程设置为守护线程，就表示这个线程是不重要的，进程退出的时候不需要等待这个线程执行完成。 &mdash;&mdash;&mdash;《Python核心编程 第三版》</p></blockquote><p>在Thread对象中默认所有线程都是非守护线程，这里有两个例子说明区别。这段代码执行的时候就没指定<code>my_thread</code>的<code>daemon</code>属性，所以默认为非守护，所以进程等待他结束。最后就可以看到100个hello,world</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># coding=utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hello_world</span>():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>            print <span style=color:#e6db74>&#39;hello,world&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>        my_thread <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>hello_world)
</span></span><span style=display:flex><span>        my_thread<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><p>这里设置了<code>my_thread</code>为守护线程，所以进程直接就退出了，并没有等待他的结束，所以我们看不到100个hello,world只有几个而已。甚至还会抛出一个异常告诉我们有线程没结束。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># coding=utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hello_world</span>():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>            print <span style=color:#e6db74>&#39;hello,world&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>        my_thread <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>hello_world)
</span></span><span style=display:flex><span>        my_thread<span style=color:#f92672>.</span>daemon <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>   <span style=color:#75715e># 设置了标志位True</span>
</span></span><span style=display:flex><span>        my_thread<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><h1 id=0x04-传个参数>0X04 传个参数</h1><p>之前的代码都是直接执行一段代码，没有过参数的传递，那么怎么传递参数呢？其实还是很简单的。<code>threading.Thread(target=hello_world, args=('hello,', 'world'))</code>就可以了。args后面跟的是一个元组，如果没有参数可以不写，如果有参数就直接在元组里按顺序添加就行了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># coding=utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hello_world</span>(str_1, str_2):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>            print str_1 <span style=color:#f92672>+</span> str_2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>        my_thread <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>hello_world, args<span style=color:#f92672>=</span>(<span style=color:#e6db74>&#39;hello,&#39;</span>, <span style=color:#e6db74>&#39;world&#39;</span>))    <span style=color:#75715e># 这里传递参数</span>
</span></span><span style=display:flex><span>        my_thread<span style=color:#f92672>.</span>start()
</span></span></code></pre></div><h1 id=0x05-再来个多线程>0X05 再来个多线程</h1><p>threading有三种创建Thread对象的方式，但是一般只会用到两种，一种是上面<code>0X02</code>说的传个函数进去，另一种就是这里说的继承<code>threading.Thread</code>。在这儿我们自己定义了两个类，类里重写了run()方法，也就是调用start()之后执行的代码，开启线程就和之前开启是一样的。之前的方式更面向过程，这个更面向对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># coding=utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThreadHello</span>(threading<span style=color:#f92672>.</span>Thread):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>                print <span style=color:#e6db74>&#39;hello&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThreadWorld</span>(threading<span style=color:#f92672>.</span>Thread):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>                print <span style=color:#e6db74>&#39;world&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>        thread_hello <span style=color:#f92672>=</span> MyThreadHello()
</span></span><span style=display:flex><span>        thread_world <span style=color:#f92672>=</span> MyThreadWorld()
</span></span><span style=display:flex><span>        thread_hello<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>        thread_world<span style=color:#f92672>.</span>start()
</span></span></code></pre></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2025-01-17</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/python/>Python</a>,&nbsp;<a href=/tags/thread/>Thread</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/linux-mysql-mariadb-simple/ class=prev rel=prev title="Linux 下 MariaDB/MySql 的安装配置、用户管理和备份"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Linux 下 MariaDB/MySql 的安装配置、用户管理和备份</a>
<a href=/posts/page-swap-simple/ class=next rel=next title=简述几种简单的页面置换算法>简述几种简单的页面置换算法<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.152.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.0"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2015 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://blog.programmer.work target=_blank>Shawn</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/gitalk/gitalk.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/gitalk/gitalk.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{gitalk:{admin:["shawn-bluce"],clientID:"Ov23ligzD7mU8WBsue6H",clientSecret:"a832d1ba967e3a40f5485aa05e2a9e76f2d77901",id:"2016-12-12T07:39:00Z",owner:"shawn-bluce",repo:"blog-comments",title:"Python 使用 threading 实现多线程"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>